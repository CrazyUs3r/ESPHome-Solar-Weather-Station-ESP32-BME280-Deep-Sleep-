substitutions:
  #Deep Sleep 
  wake_time: '5s'
  sleep_time: '35min'

  #Battery
  max_battery_voltage: '4.2'
  min_battery_voltage: '3.2'

  #Sys
  name: Wetterstation
  refresh: 2s

esphome:
  name: wetterstation
  friendly_name: Wetterstation
  project:
    name: "CG.Wetterstation"
    version: "2025.11.21"
  platformio_options:
        upload_speed: 115200
        board_build.f_flash: 80000000L
  on_boot:
    - priority: -200 
      then:
        - component.update: init_temp
        - component.update: solarV
        - if:
            condition:
              lambda: return id(last_update_global).length() > 0;
            then:
              - text_sensor.template.publish:
                  id: last_update_time
                  state: !lambda 'return id(last_update_global);'
        - lambda: |-
            id(wakeup_counter)++;
        - component.update: wakeups_today
        - delay: 200ms
        - component.update: wakeups_today
        - script.execute: decide_solar_sleep
        - script.execute: consider_deep_sleep
        - script.execute: reset_min_max_if_new_day

esp32:
  board: nodemcu-32s
  framework:
    type: arduino
    advanced:
      ignore_efuse_custom_mac: false

# Enable logging
logger:
  initial_level: ERROR
  baud_rate: 0

select:
  - platform: logger
    name: "Logger select"

# Enable Home Assistant API
api:
  encryption:
    key: !secret key_api
  reboot_timeout: 0s
  on_client_connected:
    then:
      - lambda: |-
          id(api_connected) = true;
  on_client_disconnected:
    then:
      - lambda: |-
          id(api_connected) = false;

ota:
  - platform: esphome
    password: !secret key_ota
    on_end:
      then:
        - homeassistant.service: 
            service: input_boolean.turn_on
            data:
              entity_id: input_boolean.wetterstation_deep_sleep

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  domain: <your domain>
  fast_connect: true
  power_save_mode: light

  manual_ip:
    static_ip: <your ip>
    gateway: !secret gateway
    subnet: !secret subnet
    dns1: !secret dns1

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: $name Hotspot
    password: !secret wifi_ap_key

    manual_ip:
      static_ip: 192.168.33.1
      gateway: 192.168.33.254
      subnet: 255.255.255.0

captive_portal:

script:
  - id: consider_deep_sleep
    mode: restart
    then:
        - delay: 5s
        - if:
            condition:
              binary_sensor.is_off: wetterstation_deep_sleep
            then:
              - deep_sleep.prevent: deep_sleep_1
              - text_sensor.template.publish:
                  id: deep_sleep_status
                  state: "Schlafmodus Deaktiviert"
            else:
              - text_sensor.template.publish:
                  id: deep_sleep_status
                  state: "Schlafmodus Aktiviert"
              - delay: 7s
              - wait_until:
                  condition:
                    lambda: return id(homeassistant_time).now().is_valid();
                  timeout: 15s
              - component.update: last_update_time
              - delay: 200ms
              - lambda: |-
                  id(wakeup_counter)++;
              - component.update: wakeups_today
              - script.execute: decide_solar_sleep
              - script.wait: decide_solar_sleep
              - deep_sleep.enter:
                  id: deep_sleep_1
                  sleep_duration: !lambda "return id(dynamic_sleep_duration) * 1000;"
  - id: reset_min_max_if_new_day
    mode: restart
    then:
      - lambda: |-
          auto now = id(homeassistant_time).now();
          if (now.day_of_month != id(last_reset_day)) {
            id(last_reset_day) = now.day_of_month;
            // Temperatur zurücksetzen
            if (!isnan(id(bme280_temperature).state)) {
              id(temp_min) = id(bme280_temperature).state;
              id(temp_max) = id(bme280_temperature).state;
            }
            // Humidity zurücksetzen
            if (!isnan(id(bme280_humidity).state)) {
              id(hum_min) = id(bme280_humidity).state;
              id(hum_max) = id(bme280_humidity).state;
            }
            id(wakeup_counter) = 1;
            id(wakeups_today).update();
            id(ttemp_min).update();
            id(ttemp_max).update();
            id(thum_min).update();
            id(thum_max).update();
          }
  - id: decide_solar_sleep
    mode: restart
    then:
      - lambda: |-
          float solar = id(solarV).state;
          int sleep_s = 0;
          if (solar > 4.5) {
            sleep_s = 20 * 60;  // viel Sonne → 20min
          } else if (solar > 2.5) {
            sleep_s = 35 * 60;  // mittel → 35min (Standard)
          } else if (solar > 1.0) {
            sleep_s = 45 * 60;  // schwach → 45min
          } else {
            sleep_s = 70 * 60; // Nacht → 70min
          }
          if (sleep_s != id(dynamic_sleep_duration)) {
            id(dynamic_sleep_duration) = sleep_s;
            id(sleep_time_text).update();
            id(sleep_time_seconds).update();
          }

globals:
  - id: R1
    type: float
    restore_value: yes
    initial_value: "97200.0"  # Beispielwert für R1, ersetzen Sie ihn durch Ihren gemessenen Wert
  - id: R2
    type: float
    restore_value: yes
    initial_value: "26800.0"  # Beispielwert für R2, ersetzen Sie ihn durch Ihren gemessenen Wert
  - id: api_connected
    type: bool
    restore_value: no
    initial_value: "false"
  - id: last_update_global
    type: std::string
    restore_value: yes
    initial_value: '""'
  - id: temp_min
    type: float
    restore_value: yes
    initial_value: '100.0'
  - id: temp_max
    type: float
    restore_value: yes
    initial_value: '-100.0'
  - id: hum_min
    type: float
    restore_value: yes
    initial_value: '100.0'
  - id: hum_max
    type: float
    restore_value: yes
    initial_value: '-100.0'
  - id: last_reset_day
    type: int
    restore_value: yes
    initial_value: '0'
  - id: dynamic_sleep_duration
    type: int
    restore_value: no
    initial_value: "2100"
  - id: wakeup_counter
    type: int
    restore_value: yes
    initial_value: "0"


# Zeit von Homeassistant übernehmen
time:
  - platform: homeassistant
    id: homeassistant_time
    timezone: Europe/Berlin

i2c:
  sda: 21
  scl: 22
  scan: True 

sensor:
  - platform: uptime
    name: "Time"
    id: up_time
    unit_of_measurement: "s"
    update_interval: $refresh
    
  - platform: wifi_signal
    name: "RSSI"
    id: rssi
    update_interval: $refresh
    on_value:
      then:
        - lambda: |-
            if (x >= -50) {
              id(wifi_signal_text).publish_state("Excellent");
            } else if (x >= -60) {
              id(wifi_signal_text).publish_state("Good");
            } else if (x >= -75) {
              id(wifi_signal_text).publish_state("Fair");
            } else if (x >= -100) {
              id(wifi_signal_text).publish_state("Weak");
            } else {
              id(wifi_signal_text).publish_state("Very Weak");
            }

  - platform: bme280_i2c
    temperature:
      name: "BME280 Temperature"
      id: bme280_temperature
      unit_of_measurement: "°C"
      icon: "mdi:thermometer"
      device_class: "temperature"
      state_class: "measurement"
      accuracy_decimals: 2
      oversampling: 4x
      filters:
        - offset: -0.35
        - lambda: !lambda |-
            return (float) ((int)(x * 100 + 0.5)) / 100.0;
      on_value:
        then:
          - lambda: |-
              if (!isnan(x)) {
                if (x < id(temp_min)) {
                  id(temp_min) = x;
                }
                if (x > id(temp_max)) {
                  id(temp_max) = x;
                }
              id(ttemp_min).update();
              id(ttemp_max).update();
              }
    pressure:
      name: "BME280 Pressure"
      id: bme280_pressure
      unit_of_measurement: "hPa"
      icon: "mdi:gauge"
      device_class: "pressure"
      state_class: "measurement"
      accuracy_decimals: 2
      oversampling: 4x
      filters:
        - offset: -1.3
        - lambda: !lambda |-
            return (float) ((int)(x * 100 + 0.5)) / 100.0;
    humidity:
      name: "BME280 Humidity"
      id: bme280_humidity
      unit_of_measurement: "%"
      icon: "mdi:water-percent"
      device_class: "Humidity"
      state_class: "measurement"
      accuracy_decimals: 2
      oversampling: 4x
      filters:
        - offset: 0.0
        - lambda: !lambda |-
            return (float) ((int)(x * 100 + 0.5)) / 100.0;
      on_value:
        then:
          - lambda: |-
              if (!isnan(x)) {
                if (x < id(hum_min)) {
                  id(hum_min) = x;
                }
                if (x > id(hum_max)) {
                  id(hum_max) = x;
                }
              id(thum_min).update();
              id(thum_max).update();
              }
          - component.update: altitude
          - component.update: tau
    address: 0x76
    update_interval: $refresh
    
  - platform: template
    id: altitude
    name: "Altitude"
    lambda: |-
      const float STANDARD_SEA_LEVEL_PRESSURE = 1013.25; //in hPa, see note
      return ((id(bme280_temperature).state + 273.15) / 0.0065) *
        (powf((STANDARD_SEA_LEVEL_PRESSURE / id(bme280_pressure).state), 0.190234) - 1); // in meter
    accuracy_decimals: 2
    icon: 'mdi:signal'
    unit_of_measurement: 'm'

  - platform: absolute_humidity
    name: "Absolute Humidity"
    temperature: bme280_temperature
    humidity: bme280_humidity

  - platform: template
    id: tau
    name: "Taupunkt"
    lambda: |-
      return (243.5*(log(id(bme280_humidity).state/100)+((17.67*id(bme280_temperature).state)/
      (243.5+id(bme280_temperature).state)))/(17.67-log(id(bme280_humidity).state/100)-
      ((17.67*id(bme280_temperature).state)/(243.5+id(bme280_temperature).state))));
    unit_of_measurement: °C
    accuracy_decimals: 2
    icon: 'mdi:thermometer-alert'

  - platform: adc
    pin: GPIO34
    name: "Spannung Battery"
    id: BatteryS
    state_class: "measurement"
    update_interval: $refresh
    accuracy_decimals: 2
    attenuation: Auto
    entity_category: diagnostic
    filters:
      - multiply: 1.017
      - median:
          window_size: 3
      - sliding_window_moving_average:
          window_size: 5
      - lambda: |-
          float voltage = x;
          float R1_value = id(R1); 
          float R2_value = id(R2);
          float result = voltage / (R2_value / (R1_value + R2_value));
          return (float) ((int)(result * 100 + 0.5)) / 100.0;
    on_value:
        then:
          - component.update: batpercent

  - platform: template
    name: "Battery level"
    id: batpercent
    unit_of_measurement: '%'
    device_class: battery
    entity_category: diagnostic
    update_interval: never
    lambda: |-
      float voltage = id(BatteryS).state;
      float battery_level = (voltage - $min_battery_voltage) / ($max_battery_voltage - $min_battery_voltage) * 100.0;
      return (battery_level < 0.0) ? 0.0 : ((battery_level > 100.0) ? 100.0 : battery_level);

  - platform: adc
    pin: GPIO35
    name: "Spannung Solar"
    id: solarV
    state_class: measurement
    update_interval: $refresh
    accuracy_decimals: 2
    attenuation: Auto
    entity_category: diagnostic
    filters:
      - round: 2 
      - multiply: 1.017
      - median:
          window_size: 3
      - sliding_window_moving_average:
          window_size: 5 
      - lambda: |-
          if (x <= 0.5) {
            return 0.0;
          } else {
            float voltage = x;
            float R1_value = id(R1); 
            float R2_value = id(R2);
            float result = voltage / (R2_value / (R1_value + R2_value));
            return result;
          }

  - platform: internal_temperature
    name: "Internal Temperature"
    id: init_temp 
    update_interval: never
    accuracy_decimals: 2
    filters:
      - lambda: !lambda |-
          return (float) ((int)(x * 100 + 0.5)) / 100.0;

  # ----------------------------
  # MIN / MAX TEMPERATURE
  # ----------------------------
  - platform: template
    name: "Temperatur Minimum"
    id: ttemp_min 
    lambda: |-
      return id(temp_min);
    update_interval: never
    device_class: "temperature"
    accuracy_decimals: 2
    unit_of_measurement: "°C"

  - platform: template
    name: "Temperatur Maximum"
    id: ttemp_max 
    lambda: |-
      return id(temp_max);
    update_interval: never
    device_class: "temperature"
    accuracy_decimals: 2
    unit_of_measurement: "°C"

  # ----------------------------
  # MIN / MAX HUMIDITY (NEU!)
  # ----------------------------
  - platform: template
    name: "Humidity Minimum"
    id: thum_min
    lambda: "return id(hum_min);"
    update_interval: never
    unit_of_measurement: "%"
    accuracy_decimals: 2

  - platform: template
    name: "Humidity Maximum"
    id: thum_max
    lambda: "return id(hum_max);"
    update_interval: never
    unit_of_measurement: "%"
    accuracy_decimals: 2

  - platform: template
    name: "Sleep Time Seconds"
    id: sleep_time_seconds
    entity_category: diagnostic
    accuracy_decimals: 0
    lambda: |-
      return id(dynamic_sleep_duration);
    update_interval: never

  - platform: template
    name: "Wakeups heute"
    id: wakeups_today
    accuracy_decimals: 0
    lambda: |-
      return id(wakeup_counter);
    update_interval: never

text_sensor:
  - platform: template
    name: "Deep Sleep Status"
    entity_category: diagnostic
    id: deep_sleep_status
    lambda: |-
      if (id(wetterstation_deep_sleep).state) {
        return {"Schlafmodus Aktiviert"};
      } else {
        return {"Schlafmodus Deaktiviert"};
      }
    update_interval: 1s

  - platform: template
    name: "Last Update"
    id: last_update_time
    entity_category: diagnostic
    update_interval: never
    lambda: |-
      auto now = id(homeassistant_time).now();
      // Wenn noch keine gültige Zeit vorhanden ist:
      if (!now.is_valid()) {
        // Letzten gültigen Wert beibehalten
        if (id(last_update_global).length() > 0) {
          return id(last_update_global);
        } else {
          return {"--"};
        }
      }
      // aktuelle Zeit
      auto new_time = now.strftime("%H:%M:%S %d-%m-%Y");
      // Nur wenn sich der Wert ändert
      if (new_time != id(last_update_global)) {
        id(last_update_global) = new_time;
      }
      return id(last_update_global);


  - platform: template
    name: "RSSI Signal"
    id: wifi_signal_text
    entity_category: diagnostic
  
  - platform: template
    name: "Systemstatus"
    lambda: |-
      if (!id(api_connected)) {
        return {{"API getrennt!"}};
      } else {
        return {{"System läuft einwandfrei"}};
      }
    entity_category: diagnostic
    update_interval: $refresh

  - platform: template
    name: "Batterie Status"
    lambda: |-
      if (id(batpercent).state >= 80) return {"Voll"};
      if (id(batpercent).state >= 50) return {"OK"};
      if (id(batpercent).state >= 20) return {"Niedrig"};
      return {"Kritisch"};
    entity_category: diagnostic
    update_interval: $refresh   

  - platform: template
    name: "Sleep Time"
    id: sleep_time_text
    lambda: |-
      if (id(dynamic_sleep_duration) == 1200) return {"20min"};
      if (id(dynamic_sleep_duration) == 2100) return {"35min"};
      if (id(dynamic_sleep_duration) == 2700) return {"45min"};
      if (id(dynamic_sleep_duration) == 4200) return {"70min"};
      return {"??"};
    entity_category: diagnostic
    update_interval: $refresh

binary_sensor:
  - platform: status
    name: "Status"
    id: esp_status

  - platform: homeassistant
    name: "Wetterstation_deep_sleep"
    id: wetterstation_deep_sleep
    entity_id: input_boolean.wetterstation_deep_sleep
    trigger_on_initial_state: true
    on_state:
      then:
        - script.execute: consider_deep_sleep

button:
  - platform: template
    name: "Reset Min/Max"
    on_press:
        then:
          - lambda: |-
              if (!isnan(id(bme280_temperature).state)) {
                id(temp_min) = id(bme280_temperature).state;
                id(temp_max) = id(bme280_temperature).state;
                id(hum_min) = id(bme280_humidity).state;
                id(hum_max) = id(bme280_humidity).state;
              }

switch:
    - platform: restart
      name: "Restart"
      id: wetterstation_restart

deep_sleep:
  id: deep_sleep_1
